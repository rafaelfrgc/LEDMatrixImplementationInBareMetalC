# Exercise 2

## Summary

- [Question 1: Compilation with Various Optimization Levels](#question-1)
  - [O0 Optimization Level](#for-the-o0-optimization-level)
  - [O1 Optimization Level](#for-the-o1-optimization-level)
  - [O2 Optimization Level](#for-the-o2-optimization-level)
  - [Os Optimization Level](#for-the-os-optimization-level)
- [Question 3: Pointer Declarations](#question-3)
  - [Changing to `const char *mesg`](#changing-to-const-char-)
- [Question 2: Using Static Declaration](#question-2)
- [Question 3: Pointer Declarations](#question-3)
  - [Changing to `const char *mesg`](#changing-to-const-char-mesg)
  - [Changing to `const char * const mesg`](#changing-to-const-char--const-mesg)
- [Final Thoughts](#final-thoughts)

## Question 1

**Question:** Compilez sans édition de lien ce code-ci (<http://bit.ly/2ApXoDl>) pour ARM
avec une chaîne récente, et avec les optimisations suivantes : Os, O0, O1
et O2. Pour chaque niveau d'optimisation, justifiez la taille des sections de
données que vous obtenez.

**Solution:**

To start this exercise, we will first compile the code without linking (ing -c) for each optimization level:

```bash
arm-none-eabi-gcc -c -O0 -o ex2_O0.o ex2.c
arm-none-eabi-gcc -c -O1 -o ex2_O1.o ex2.c
arm-none-eabi-gcc -c -O2 -o ex2_O2.o ex2.c
arm-none-eabi-gcc -c -Os -o ex2_Os.o ex2.c
```

To see the differences, we can analyze the headers (using the `-h` flag), the content (using the `-s` flag)  and the assembly code (using the `-d` flag) of the object files generated by running the following commands:

```bash
arm-none-eabi-objdump -h ex2_O0.o
arm-none-eabi-objdump -h ex2_O1.o
arm-none-eabi-objdump -h ex2_O2.o
arm-none-eabi-objdump -h ex2_Os.o
```

```bash
arm-none-eabi-objdump -s ex2_O0.o
arm-none-eabi-objdump -s ex2_O1.o
arm-none-eabi-objdump -s ex2_O2.o
arm-none-eabi-objdump -s ex2_Os.o
```

```bash
arm-none-eabi-objdump -d ex2_O0.o
arm-none-eabi-objdump -d ex2_O1.o
arm-none-eabi-objdump -d ex2_O2.o
arm-none-eabi-objdump -d ex2_Os.o
```

By repeating these commands for each question, it is possible to obtain each and every output necessary to analyse the code and answer the questions.

### For the O0 Optimization Level

With the outputs, we can observe the following: two strings "Hello World!" in the .rodata section, instead of just one. This is because, given the lack of optimization, the compiler duplicates string in the code, one is associated to "const char mesg[]" global variable and the other one to the function "printf(mesg)".

Also, analyzing the assembly code generated using the `-d` flag, we can see that the first `printf(mesg)` is replaced by a call to the function `puts`. Looking at the manual for the functions `puts` and `printf`, we can see that `puts` is a simpler function than `printf`, taking less arguments and handling a simple string terminated by a newline character. However, the compiler does not optimize the second `printf()` call, as it is a more complex and formatted string using placeholders.

### For the O1 Optimization Level

Doing the same analysis for the O1 optimization level:

We can see that the sizes for the sections `.text`, `.rodata.str1.4`, and `.rodata` are smaller than in the O0 optimization level. This indicates that the compiler optimized the code by removing redundancy and simplifying it.

For the string **"Hello World!"**:

- The string in the `.rodata.str1.4` section is used for the first `printf(mesg)` call, which is replaced by the function `puts`. It is modified to **"Hello World!\0"** to avoid the newline character that `puts` appends.

- The string in the `.rodata` section stores the `mesg` array as defined in the code.

### For the O2 Optimization Level

Doing the same analysis for the O2 optimization level:

In this optimzation level, we can observe that the sizes of the sections are the same to the O1 optimization level. The `.text` section is empty, as the compiler moved the code to the `.text.startup` section, where usually the startup code is placed, like main and initialization functions.

### For the Os Optimization Level

Doing the same analysis for the Os optimization level:

We can see that every size is the same, except for the `.rodata.str1.1` section,and the `.text.startup` section, which are smaller than `.rodata.str1.4` and `.text` sections in the O1 and O2 optimization levels. This means that the text size could be reduced even more and the `rodata.str1.1` section is smaller as it is aligned to 1 byte instead of 4, as we can see in the headers "Algn" column.

### Conclusion

Summarizing the sizes of the sections for each optimization level in a table:

| Section            | -O0 (hex / dec) | -O1 (hex / dec) | -O2 (hex / dec) | -Os (hex / dec) |  
|--------------------|-----------------|-----------------|-----------------|-----------------|
| `.text`            | 0xb8 / 184      | 0x6c / 108      | 0x00 / 0        | 0x00 / 0        |
| `.text.startup`    | N/A             | N/A             | 0x6c / 108      | 0x68 / 104      |
| `.data`            | 0x04 / 4        | 0x04 / 4        | 0x04 / 4        | 0x04 / 4        |
| `.bss`             | 0x05 / 5        | 0x05 / 5        | 0x05 / 5        | 0x05 / 5        |
| `.rodata.str1.4`   | N/A             | 0x30 / 48       | 0x30 / 48       | N/A               |
| `.rodata.str1.1`   | N/A             | N/A             | N/A             | 0x2d / 45       |
| `.rodata`          | 0x40 / 64       | 0x0e / 14       | 0x0e / 14       | 0x0e / 14       |
| `.comment`         | 0x4a / 74       | 0x4a / 74       | 0x4a / 74       | 0x4a / 74       |
| `.ARM.attributes`  | 0x2a / 42       | 0x2a / 42       | 0x2a / 42       | 0x2a / 42       |
| **Total**    | **0x175** / **373**       | **0x127** / **295**       | **0x127** / **295**       | **0x120** / **288**       |


As we can see, the sizes of the sections are reduced as the optimization level increases. The `.text` section is the one that has the most significant reduction in size, as the compiler optimizes the code to remove redundancy and simplify the code. As expected and analyzed in the previous sections the Os level has the smallest size, as it applies the most aggressive optimization level, and the O0 level has the largest size, as it does not apply any optimization at all, and the code is more redundant, as we could see in the `.rodata` section.

However, one thing of note is that the biggest difference in size is between the O0 and O1 optimization levels, and the others, especially 01 and 02, have the exact same size, with the only difference being the organization of the `.text` and `.text.startup` sections.

## Question 2

**Question:** Remplacez const char mesg[] par static const char mesg[]. Expliquez les différences dans les sections de données par rapport à la question précédente (elles dépendent ici aussi des optimisations).

**Solution:**

After changing the `const char mesg[]` to `static const char mesg[]`, we will compile the code for each optimization level and analyze the sections of the object files generated as we did in the previous question. To make it quicker, we will only analyze the `.rodata` section, as it is the one that will be affected by the change. Running all the commands as we did in the previous question, and analyzing the headers and contents, the following table can be compiled:

| Section            | -O0 (hex / dec) | -O1 (hex / dec) | -O2 (hex / dec) | -Os (hex / dec) |
|--------------------|-----------------|-----------------|-----------------|-----------------|
| `.text`            | 0xb8 / 184  | 0x6c / 108  | 0x00 / 0    | 0x00 / 0    |
| `.data`            | 0x04  / 4     | 0x04 / 4    | 0x04 / 4    | 0x04 / 4    |
| `.bss`             | 0x05 / 5    | 0x05 / 5    | 0x05 / 5    | 0x05 / 5    |
| `.rodata`          | 0x40 / 64   | N/A             | N/A             | N/A             |
| `.rodata.str1.4`   | N/A             | 0x30 / 48   | 0x30 / 48   | N/A             |
| `.rodata.str1.1`   | N/A             | N/A             | N/A             | 0x2d / 45   |
| `.comment`         | 0x4a / 74   | 0x4a / 74   | 0x4a / 74   | 0x4a / 74   |
| `.ARM.attributes`  | 0x2a / 42   | 0x2a / 42   | 0x2a / 42   | 0x2a / 42   |
| `.text.startup`    | N/A             | N/A             | 0x6c / 108  | 0x68 / 104`  |
| **Total**          |**0x175** / **373**|**0x119** / **281** |**0x119** / **281**| **0x112** / **274**|

As a result, we can see that the `.rodata` section is not present anymore in the O1, O2, and Os optimization levels. That indicates that the compiler used the static keyword to limit the scope of the variable `mesg` to the file where it is declared, and as a result, the string is not stored in the `.rodata` section anymore. This allows for further optimization. The `text`, `bss`and `data` sections remain the same as in the previous question.

## Question 3

**Question:** Remplacez const char mesg[] par const char *mesg. puis par const char* const mesg. Expliquez les différences dans le code généré et les sections de données par rapport à la question 2.

**Solution:**

### Changing to `const char *mesg`


Firstly, after changing the `const char mesg[]` to `const char *mesg` and repeating the process of compiling and analyzing the object files and some disassembled code, we have the following table:

| Section           | -O0 (hex / dec) | -O1 (hex / dec) | -O2 (hex / dec) | -Os (hex / dec) |
|-------------------|-----------------|-----------------|-----------------|-----------------|
| `.text`           | 0xc0 / 192      | 0x68 / 104      | 0x00 / 0        | 0x00 / 0        |
| `.text.startup`   | N/A             | N/A             | 0x68 / 104      | 0x64 / 100      |
| `.data`           | 0x08 / 8        | 0x08 / 8        | 0x08 / 8        | 0x08 / 8        |
| `.bss`            | 0x05 / 5        | 0x05 / 5        | 0x05 / 5        | 0x05 / 5        |
| `.rodata`         | 0x30 / 48       | N/A             | N/A             | N/A             |
| `.rodata.str1.4`  | N/A             | 0x2e / 46       | 0x2e / 46       | N/A             |
| `.rodata.str1.1`  | N/A             | N/A             | N/A             | 0x2e / 46       |
| `.comment`        | 0x4a / 74       | 0x4a / 74       | 0x4a / 74       | 0x4a / 74       |
| `.ARM.attributes` | 0x2a / 42       | 0x2a / 42       | 0x2a / 42       | 0x2a / 42       |
| **Total**         |**0x171** / **369**|**0x117** / **279**|**0x117** / **279**|**0x113** / **275**|

As we can see, compared to question 2 which uses the **static** keyword, the total size of each section has reduced, except for level Os, in which the `.rodata.str1.1` section has increased from 0x2d to 0x2e. The `data` section has increased from 0x4 to 0x8, to represent the pointer to the character array. And so, because of this change in the code, the `.rodata` section is not present in the O1, O2, and Os optimization levels, similar to the previous question.

Also it is of note that within the disassembled code, instead of using `puts` as in the previous situations, the compiler uses `printf` for both. This is because, as the compiler only knows that the pointer is pointing to a address in memory, but the content of this address is not constant, it cannot know in principle how the pointed content will behave during code execution. Thus it uses the more general `printf` function. As a consequence, the size of the `.text` section is larger than in the previous question.

### Changing to `const char * const mesg`

Finally, we compile the code for each optimization level and analyze the sections of the object files generated as we did in the previous question. The following table can be compiled:

| Section           | -O0 (hex / dec) | -O1 (hex / dec) | -O2 (hex / dec) | -Os (hex / dec) |
|-------------------|-----------------|-----------------|-----------------|-----------------|
| `.text`           | 0xb8 / 184      | 0x6c / 108      | 0x00 / 0        | 0x00 / 0        |
| `.text.startup`   | N/A             | N/A             | 0x6c / 108      | 0x68 / 104      |
| `.data`           | 0x04 / 4        | 0x04 / 4        | 0x04 / 4        | 0x04 / 4        |
| `.bss`            | 0x05 / 5        | 0x05 / 5        | 0x05 / 5        | 0x05 / 5        |
| `.rodata`         | 0x44 / 68       | 0x04 / 4        | 0x04 / 4        | 0x04 / 4        |
| `.rodata.str1.4`  | N/A             | 0x3e / 62       | 0x3e / 62       | 0x3b / 59       |
| `.rodata.str1.1`  | N/A             | N/A             | N/A             | N/A             |
| `.comment`        | 0x4a / 74       | 0x4a / 74       | 0x4a / 74       | 0x4a / 74       |
| `.ARM.attributes` | 0x2a / 42       | 0x2a / 42       | 0x2a / 42       | 0x2a / 42       |
| **Total**         |**179** / **373**|**12b** / **299**  |**12b** / **299**  |**124** / **288**  |

Now, the first change we can see is the return of the `.rodata` section for all optimizations levels. This is because the `const char * const mesg` declaration makes the pointer and the pointed content constant, meaning that the pointer cannot point to another content during the execution of the code. This allows the compiler to store the string in the `.rodata` section, as it knows that the pointer will always point to the same content. Also, this allows for the return of the `puts` function instead of `printf`.

We can also note that the `data` section has returned to 0x04 in size, meaning that now the pointer  is stored in the  `.rodata` section as it has increased accordingly compared to the situation with **static** keyword. The `text` section and the other optimizations related to `.text.startup`, `.rodata.str1.4` and `.rodata.str1.1` remains the same as in the previous question.

## Final Thoughts

We analyzed the impact of different types of declarations on this exercise on the sections of the object files generated by the compiler. We observed that the use of the keywords like `static` , `const`, and also their effect on pointer declaration, can have a significant impact on the size and organization of the sections in the object files.

The ideia is that knowing how the compiler organizes the sections of the object files and what optimizations it applies can help us decide what, how, and when to use or not these keywords, what type of declaration, or where in the code to declare or not something, based on the impact they have on the effieciency and size of the code.
